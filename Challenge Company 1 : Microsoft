150. Evaluate Reverse Polish Notation


CODE:
class Solution {
   public int evalRPN(String[] tokens) {
        Deque<Integer> nums = new ArrayDeque<>();
        
        for (String s : tokens) {
            if (s.equals("+"))       nums.push(nums.pop() + nums.pop());
            else if (s.equals("-"))  nums.push(- nums.pop() + nums.pop());
            else if (s.equals("*"))  nums.push(nums.pop() * nums.pop());
            else if (s.equals("/")) {
                int b = nums.pop(), a = nums.pop();
                nums.push(a/b);
            } else  nums.push(Integer.valueOf(s));
        }
        
        return nums.pop();
    }
}



216. Combination Sum III

CODE: 
class Solution {
     public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> ans = new ArrayList<>();
    combination(ans, new ArrayList<Integer>(), k, 1, n);
    return ans;
}

private void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {
	if (comb.size() == k && n == 0) {
		List<Integer> li = new ArrayList<Integer>(comb);
		ans.add(li);
		return;
	}
	for (int i = start; i <= 9; i++) {
		comb.add(i);
		combination(ans, comb, k, i+1, n-i);
		comb.remove(comb.size() - 1);
	}
}
}





299. Bulls and Cows
class Solution {
    public String getHint(String secret, String guess) {
        HashMap<Character,Integer> seen=new HashMap<>();
        int bull=0;
        int cow=0;
        for(int i=0;i<secret.length();i++)
        {
            char c=secret.charAt(i);
            char ch=guess.charAt(i);
            if(c==ch)
                bull++;
            else
            {
            seen.put(c,seen.getOrDefault(c,0)+1);
            }
        }
        for(int i=0;i<guess.length();i++)
        {
            char ch=secret.charAt(i);
            char c=guess.charAt(i);
            if(c!=ch && seen.getOrDefault(c,0)>0)
            {
                cow++;
                seen.put(c,seen.get(c)-1);
            }
        }
        return bull+"A"+cow+"B";
    }
}



396. Rotate Function

CODE:: 
class Solution {
    int[] nums;
    
    public int getFunctionValue(int start) {
        int ans = 0,  n = nums.length;
        for (int i = 0; i < n; i++) {
            ans += nums[(start+i)%n]*i;
        }
        return ans;
    }
    
    public int maxRotateFunction(int[] ns) {
       int max = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(max, getFunction(nums, i));
        }
        return max;
    }
}



368. Largest Divisible Subset

class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
       int[] dp=new int[nums.length];
       Arrays.sort(nums);
       Arrays.fill(dp,1);
       int mx=1;
        for(int i=1;i<nums.length;i++){
           for(int j=i-1;j>=0;j--){
                if(nums[i]%nums[j]==0){
                  dp[i]=Math.max(dp[i],1+dp[j]);
                }
                mx=Math.max(mx,dp[i]);
            }
        }
        int[] ans=new int[mx];
         int prev=0;
         for(int i=nums.length-1;i>=0;i--){
             if(dp[i]==mx&& prev%nums[i]==0){
                 ans[mx-1]=nums[i];
                 prev=nums[i];
                 mx--;
             }
         }
         List<Integer> s=new ArrayList<>();
 for(int i=0;i<ans.length;i++){
     s.add(ans[i]);

 }
return s;
    }
   
}

150. Evaluate Reverse Polish Notation


CODE:
class Solution {
   public int evalRPN(String[] tokens) {
        Deque<Integer> nums = new ArrayDeque<>();
        
        for (String s : tokens) {
            if (s.equals("+"))       nums.push(nums.pop() + nums.pop());
            else if (s.equals("-"))  nums.push(- nums.pop() + nums.pop());
            else if (s.equals("*"))  nums.push(nums.pop() * nums.pop());
            else if (s.equals("/")) {
                int b = nums.pop(), a = nums.pop();
                nums.push(a/b);
            } else  nums.push(Integer.valueOf(s));
        }
        
        return nums.pop();
    }
}



216. Combination Sum III

CODE: 
class Solution {
     public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> ans = new ArrayList<>();
    combination(ans, new ArrayList<Integer>(), k, 1, n);
    return ans;
}

private void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {
	if (comb.size() == k && n == 0) {
		List<Integer> li = new ArrayList<Integer>(comb);
		ans.add(li);
		return;
	}
	for (int i = start; i <= 9; i++) {
		comb.add(i);
		combination(ans, comb, k, i+1, n-i);
		comb.remove(comb.size() - 1);
	}
}
}





299. Bulls and Cows
class Solution {
    public String getHint(String secret, String guess) {
        HashMap<Character,Integer> seen=new HashMap<>();
        int bull=0;
        int cow=0;
        for(int i=0;i<secret.length();i++)
        {
            char c=secret.charAt(i);
            char ch=guess.charAt(i);
            if(c==ch)
                bull++;
            else
            {
            seen.put(c,seen.getOrDefault(c,0)+1);
            }
        }
        for(int i=0;i<guess.length();i++)
        {
            char ch=secret.charAt(i);
            char c=guess.charAt(i);
            if(c!=ch && seen.getOrDefault(c,0)>0)
            {
                cow++;
                seen.put(c,seen.get(c)-1);
            }
        }
        return bull+"A"+cow+"B";
    }
}



396. Rotate Function

CODE:: 
class Solution {
public int maxRotateFunction(int[] nums) {
    int s=0;int maxs=Integer.MIN_VALUE; int prevs=0;
    
    for(int i: nums) s+=i;
    
    
    for(int i=0;i<nums.length;i++)
    {
        prevs+=i*nums[i];//System.out.println(prevs);
    }
    for(int i=nums.length-1; i>=0; i--)
    {
        int currs=s+prevs-nums[i]*(nums.length);
        //System.out.println(currs);
        maxs=Math.max(currs, maxs);
        prevs=currs;
    }
    
    return maxs;
    
}}



368. Largest Divisible Subset

CODE::
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
       int[] dp=new int[nums.length];
       Arrays.sort(nums);
       Arrays.fill(dp,1);
       int mx=1;
        for(int i=1;i<nums.length;i++){
           for(int j=i-1;j>=0;j--){
                if(nums[i]%nums[j]==0){
                  dp[i]=Math.max(dp[i],1+dp[j]);
                }
                mx=Math.max(mx,dp[i]);
            }
        }
        int[] ans=new int[mx];
         int prev=0;
         for(int i=nums.length-1;i>=0;i--){
             if(dp[i]==mx&& prev%nums[i]==0){
                 ans[mx-1]=nums[i];
                 prev=nums[i];
                 mx--;
             }
         }
         List<Integer> s=new ArrayList<>();
 for(int i=0;i<ans.length;i++){
     s.add(ans[i]);

 }
return s;
    }
   
}



391. Perfect Rectangle

CODE::
public class Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        long area=0;
        int up=Integer.MIN_VALUE, low = Integer.MAX_VALUE, rightest=Integer.MIN_VALUE, leftest=Integer.MAX_VALUE;
        HashMap<Integer,ArrayList<Interval>> topmap = new HashMap<>();
        HashMap<Integer,ArrayList<Interval>> bottommap = new HashMap<>();
        HashMap<Integer,ArrayList<Interval>> leftmap = new HashMap<>();
        HashMap<Integer,ArrayList<Interval>> rightmap = new HashMap<>();
        for(int i=0;i<rectangles.length;i++){
            int[] r1 = rectangles[i];
            int top = r1[3], right = r1[2], left = r1[0], bottom = r1[1];
            up = Math.max(top,up);
            low = Math.min(low, bottom);
            rightest = Math.max(right,rightest);
            leftest = Math.min(left, leftest);
            if (!topmap.containsKey(top))  topmap.put(top,new ArrayList<Interval>());
            topmap.get(top).add(new Interval(left,right));
            if (!bottommap.containsKey(bottom))  bottommap.put(bottom,new ArrayList<Interval>());
            bottommap.get(bottom).add(new Interval(left,right));
            if(!leftmap.containsKey(left)) leftmap.put(left,new ArrayList<Interval>());
            leftmap.get(left).add(new Interval(bottom,top));
            if(!rightmap.containsKey(right)) rightmap.put(right,new ArrayList<Interval>());
            rightmap.get(right).add(new Interval(bottom,top));
            area += (top-bottom)*(right-left);
        }
        if(area!=( rightest-leftest)*(up-low)) return false;
        if(bottommap.size()!=topmap.size()||leftmap.size()!=rightmap.size()) return false;
        return (compareMaps(bottommap,topmap,low) && compareMaps(rightmap,leftmap,rightest) ) ;
    }
    public boolean compareMaps(HashMap<Integer,ArrayList<Interval>> map1, HashMap<Integer,ArrayList<Interval>> map2, int side){
        for(int top: map1.keySet()  ){
            if(top==side) continue;
            List<Interval> mergedTopList = merge(map1.get(top));
            if(!map2.containsKey(top)) return false;
            List<Interval> mergedBottomeList = merge(map2.get(top));
            if(mergedBottomeList.size()!=mergedTopList.size()) return false;
            for(int i=0;i<mergedBottomeList.size();i++) {
                if(mergedBottomeList.get(i).start!=mergedTopList.get(i).start ||mergedBottomeList.get(i).end!=mergedTopList.get(i).end) return false;
            }
        }
        return true;
    }
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> res = new ArrayList<>();
        if(intervals==null||intervals.size()<2) return intervals;
        Collections.sort(intervals, new Comparator<Interval>(){public int compare(Interval i1, Interval i2) { return i1.start-i2.start; } } );
        int start = intervals.get(0).start, end=intervals.get(0).end;
        for(int i=1;i<intervals.size();i++){
            Interval cur = intervals.get(i);
            if(cur.start>end){
                res.add(new Interval(start, end) );
                start=cur.start;
            }
            if(cur.end>end) end=cur.end;
        }
        res.add(new Interval(start, end) ); 
        return res;
    }
}
class Interval {
    int start,end;
    Interval() { start = 0; end = 0; }
    Interval(int s, int e) { start = s; end = e; }
}



207. Course Schedule

CODE:
public class Solution {
public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[] indegree = new int[numCourses];
    Queue<Integer> queue = new LinkedList<Integer>();
    for(int[] pair:prerequisites){
        indegree[pair[1]]++;
    }
    for(int i=0;i<indegree.length;i++){
        if(indegree[i]==0){
            queue.add(i);
        }
    }
    int select = 0;
    while(!queue.isEmpty()){
        numCourses--;
        int course = queue.poll();
        for(int[] pair:prerequisites){
            if(pair[0]==course){
                indegree[pair[1]]--;
                if(indegree[pair[1]]==0){
                    queue.add(pair[1]);
                }
            }
        }
    }
    return numCourses==0;
}
}


2467. Most Profitable Path in a Tree
